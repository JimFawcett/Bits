C:\github\JimFawcett\Bits\Rust\rust_data
> cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.00s
     Running `target\debug\rust_data.exe`

-------------------------
 Demonstrate Rust types
-------------------------

-------------------------
 create and initialize
-------------------------

--- initialize primitives ---
  int, i64
  value: 42, size: 8
  double, f64
  value: 3.15927, size: 8
  arr, [i32; 3]
  value: [1, 2, 3], size: 12

--- initialize std::lib types ---
  vec, alloc::vec::Vec<i32>
  value: [1, 2, 3, 2, 1], size: 24
  map, std::collections::hash::map::HashMap<&str, i32>
  value: {"one": 1, "two": 2, "zero": 0}, size: 48

--- initialize user-defined type ---
  udt, rust_data::create_initialize::Demo
  value: Demo { name: "demo" }, size: 24

-------------------------
 demonstrate copy and pass-by-value
-------------------------

--- direct integer copy ---
  source: 42
  destin: 42

--- direct copy of array of f64 ---
  source: [3.14, 0.5, -0.75]
  destin: [3.14, 0.5, -0.75]

--- direct vector clone ---
  source: [1, 2, 3, 2, 1]
  destin: [1, 2, 3, 2, 1]

--- pass-by-value copies integer ---
  T, i64
  value: 42, size: 8
  value mutated internally to 0

--- pass-by-value moves vector ---
  T, alloc::vec::Vec<i32>
  value: [1, 2, 3, 2, 1], size: 24
  value mutated internally to []

--------------------------------------------------
  demonstrate pass-by-reference
--------------------------------------------------

-----------------------------------
  these demos have side effects
-----------------------------------

--- pass integer reference ---
  before pass_by_ref: 42
  T, &mut i64
  value: 42, size: 8
  value mutated internally to 0
  after pass_by_ref: 0

--- pass reference to vector ---
  before pass_by_ref: [1, 2, 3, 4, 5]
  T, &mut alloc::vec::Vec<i32>
  value: [1, 2, 3, 4, 5], size: 8
  value mutated internally to []
  after pass_by_ref: []

--- pass reference to HashMap ---
  before pass_by_ref: {"zero": 0, "two": 2, "one": 1}
  T, &mut std::collections::hash::map::HashMap<&str, i32>
  value: {"zero": 0, "two": 2, "one": 1}, size: 8
  value mutated internally to {}
  after pass_by_ref: {}

-------------------------
 demonstrate move
-------------------------

--- demo_move for String ---
  s: "a string"
  static address of s: 0x6a4c5af440
  heap address of s's buffer: 0x1d0d45282e0
  check - address of first byte of chars: 0x1d0d45282e0
--- let t:String = s; // move ---
  t: "a string"
  static address of t: 0x6a4c5af4a0
  heap address of t's buffer: 0x1d0d45282e0

  Note: s and t are unique objects
  that share same buffer
  but now, s is invalid

--- demo_move for Vec ---
  u: [1, 2, 3, 2, 1]
  static address of u: 0x6a4c5af550
  heap address of u's buffer: 0x1d0d4534980
  check - address of u[0]: 0x1d0d4534980
--- let v:Vec<u8> = u; // move ---
  v: [1, 2, 3, 2, 1]
  static address of v: 0x6a4c5af5b0
  heap address of v's buffer: 0x1d0d4534980

-------------------------
 demonstrate mutability
-------------------------

--- demo_mutable for primitives ---

--- demo_mutable for primitives ---
  original value: 42, changed value:  43
  original value: 3.14159, changed value:  4.14159

--- demo_mutable for std::lib types ---
  original value: [1, 2, 3], changed value:  [1, 3, 3]
  original value: {"one": 1, "two": 2, "zero": 0}
  changed value:  {"one": 2, "two": 2, "zero": 0}


-------------------------
 demonstrate references
-------------------------

--- demo_ref immutable ---
  r1v1: [1, 2, 3, 2, 1]
  r2v1: [1, 2, 3, 2, 1]

--- demo_ref mutable ---
  r1v2: [1, 2, 3, 4, 5]
  mr2v2: [1, 2, 3, 4, 5, 42]


That's all Folks!!


C:\github\JimFawcett\Bits\Rust\rust_data
