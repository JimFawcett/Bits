 Demonstrate Python Objects
----------------------------

--------------------------------------------------
  All Python types are reference-based
  with values in the managed heap. That
  has consequences we explore in this demo.
-------------------------------------------------- 

--------------------------------------------------
  primitive and library types
-------------------------------------------------- 

d1 =  3.1415927
s1 =  'a string'
--- s2 = s1 ---
s1 a string 1974941848240 
s2 a string 1974941848240 
--- s2 += " and more" ---
s2 a string and more 1974942127632 
s1 a string 1974941848240 

--------------------------------------------------
  Assignment, in Python, assigns references not
  values.  So s1 and s2 share same heap instance
  But strings are immutable. So when a change is
  made to one, that creates a new changed instance
  without changing the original.
-------------------------------------------------- 

l1 {
  you, me, them, us
}

l1 =  ['you', 'me', 'them', 'us'] 

--- l2 = l1 ---
--- l2.append("everyone") ---

l2 =  ['you', 'me', 'them', 'us', 'everyone']
l1 =  ['you', 'me', 'them', 'us', 'everyone'] 

--- l2[1] = "myself" ---

l2 =  ['you', 'myself', 'them', 'us', 'everyone']
l1 =  ['you', 'myself', 'them', 'us', 'everyone']

--------------------------------------------------
  Changes to target of assignment affect source
  except for immutable strings.  "caveat emptor"
--------------------------------------------------

--------------------------------------------------
  user defined type
--------------------------------------------------

--- p1a = Point4D() ---
--- AnalysisObj.showTypeShowable(p1a, "p1a", nl) ---
p1a <class 'PointsObj.Point4D'> dynamic
p1a {
  x:0.0, y:0.0, z:0.0
  t:2024-01-14 18:41:57.225653
}

p1a {
  x:2, y:-3.5, z:-42
  t:2024-01-14 18:41:57.225653
}
--- p1b = p1a ---
p1b {
  x:2, y:-3.5, z:-42
  t:2024-01-14 18:41:57.225653
}
--- p1b.y = 13 ---
p1b {
  x:2, y:13, z:-42
  t:2024-01-14 18:41:57.225653
}
p1a {
  x:2, y:13, z:-42
  t:2024-01-14 18:41:57.225653
}
--------------------------------------------------
  Reference assigned, not value.  So change
  in P1b changed source p1a.
--------------------------------------------------

--- p1c = copy.deepcopy(p1b) ---
p1c {
  x:2, y:13, z:-42
  t:2024-01-14 18:41:57.225653
}
p1b {
  x:2, y:13, z:-42
  t:2024-01-14 18:41:57.225653
}
--- p1c.z = 12 ---
p1c {
  x:2, y:13, z:12
  t:2024-01-14 18:41:57.225653
}
p1b {
  x:2, y:13, z:-42
  t:2024-01-14 18:41:57.225653
}
--------------------------------------------------
  p1c.z reference assigned, not value. But no
  change in p1b since p1c is deep clone of p1b.
--------------------------------------------------

--- t5 = (1, 2, 3) ---
t5 (1, 2, 3) 1974942114176
--- t6 = [1, t5, "weird"] ---
t6 [1, (1, 2, 3), 'weird'] 1974941790912
t6 <class 'list'> dynamic
value:  [1, (1, 2, 3), 'weird'] , size:  80
-- t5 = 1 + 1j : new object --
t5 (1+1j) 1974941491280
t6 [1, (1, 2, 3), 'weird'] 1974941790912

--------------------------------------------------
  new object for t5, t6 not affected
--------------------------------------------------

-- iterate over t6 children --
elem 1 1974940467440
elem (1, 2, 3) 1974942114176
elem weird 1974942119920

That's all folks!

C:\github\JimFawcett\Bits\Python\Py_Objects
>
