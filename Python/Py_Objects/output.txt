 Demonstrate Python Objects
----------------------------

--------------------------------------------------
  All Python types are reference-based
  with values in the managed heap. That
  has consequences we explore in this demo.
--------------------------------------------------

--------------------------------------------------
  primitive and library types
--------------------------------------------------

d1 =  3.1415927
s1 =  'a string'
--- s2 = s1 ---
s1 a string 1315314143600
s2 a string 1315314143600
--- s2 += " and more" ---
s2 a string and more 1315314423072
s1 a string 1315314143600

--------------------------------------------------
  Assignment, in Python, assigns references not
  values.  So s1 and s2 share same heap instance
  But strings are immutable. So when a change is
  made to one, that creates a new instance without
  changing the original.
--------------------------------------------------

l1 {
  you, me, them, us
}

l1 =  ['you', 'me', 'them', 'us']

--- l2 = l1 ---
--- l2.append("everyone") ---

l2 =  ['you', 'me', 'them', 'us', 'everyone']
l1 =  ['you', 'me', 'them', 'us', 'everyone']

--- l2[1] = "myself" ---

l2 =  ['you', 'myself', 'them', 'us', 'everyone']
l1 =  ['you', 'myself', 'them', 'us', 'everyone']

--------------------------------------------------
  Changes to target of assignment affect source
  except for immutable strings.  "caveat emptor"
--------------------------------------------------

--------------------------------------------------
  user defined type
--------------------------------------------------

--- p1a = Point4D() ---
--- AnalysisObj.showTypeShowable(p1a, "p1a", nl) ---
p1a <class 'PointsObj.Point4D'> dynamic
p1a {
  x:0.0, y:0.0, z:0.0
  t:2023-11-24 13:12:22.800443
}

p1a {
  x:2, y:-3.5, z:-42
  t:2023-11-24 13:12:22.800443
}
--- p1b = p1a ---
p1b {
  x:2, y:-3.5, z:-42
  t:2023-11-24 13:12:22.800443
}
--- p1b.y = 13 ---
p1b {
  x:2, y:13, z:-42
  t:2023-11-24 13:12:22.800443
}
p1a {
  x:2, y:13, z:-42
  t:2023-11-24 13:12:22.800443
}
--------------------------------------------------
  Reference assigned, not value.  So change
  in P1b changed source p1a.
--------------------------------------------------

--- p1c = copy.deepcopy(p1b) ---
p1c {
  x:2, y:13, z:-42
  t:2023-11-24 13:12:22.800443
}
p1b {
  x:2, y:13, z:-42
  t:2023-11-24 13:12:22.800443
}
--- p1c.z = 12 ---
p1c {
  x:2, y:13, z:12
  t:2023-11-24 13:12:22.800443
}
p1b {
  x:2, y:13, z:-42
  t:2023-11-24 13:12:22.800443
}
--------------------------------------------------
  p1c.z reference assigned, not value. But no
  change in p1b since p1c is deep clone of p1b.
--------------------------------------------------

--- t5 = (1, 2, 3) ---
t5 (1, 2, 3) 1315314409856
--- t6 = [1, t5, "weird"] ---
t6 [1, (1, 2, 3), 'weird'] 1315314755456
t6 <class 'list'> dynamic
value:  [1, (1, 2, 3), 'weird'] , size:  80
-- t5 = 1 + 1j : new object --
t5 (1+1j) 1315313786960
t6 [1, (1, 2, 3), 'weird'] 1315314755456

--------------------------------------------------
  new object for t5, t6 not affected
--------------------------------------------------

-- iterate over t6 children --
elem 1 1315312763120
elem (1, 2, 3) 1315314409856
elem weird 1315314415664

That's all folks!


